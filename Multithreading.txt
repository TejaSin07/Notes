==============
Multi Threading
==============

Task : Work

Single Tasking : Performing only one task at a time is called as Single Tasking

Ex: 

1) Explain the topic
2) Dictate the notes
3) Ask questions

-> If we perform single tasking then it will take lot of time to complete all our work.
Multi Tasking : Performing multiple tasks at a time is called as Multi Tasking

Ex:

1) Walking & listening music
2) Speaking and Writing
3) Reading book & eating

-> If we perform multi tasking then we complete multiple works at a time.
-> Multi Tasking we can achieve in 2 ways

1) Process Based Multi Tasking
	Ex: Windows OS

2) Thread Based Multi Tasking
-> To execute our program logics parallelly then we need to go for Thread Based Multi Tasking
-> Using Thread Based Multi Tasking our program can complete the work quickly
-> To implement Thread Based Multi Tasking we will use Multi Threading
-> Java Supports Multi Threading

==================================
Use case to go for Multi Threading
==================================

1) Send sms to all customers at a time
2) Send Email to all customers at a time
3) Generate & Send Bank Statements to all customers in email


Note: The main aim of Multi Tasking is used execute our program logic parallelly so that we can complete more work in less time.
-> For Every Java program execution, JVM will create one thread by default. That thread is called as Main thread.

// Java Program to get the details of Main thread

public class Demo {
	public static void main(String... args) {
		Thread currentThread = Thread.currentThread();
		System.out.println(currentThread.getName()); // main
	}
}


Note: Thread is a predefined class available in java.lang package. In Thread class we have a static method currentThread ( ).

NOTE:
=====
Understanding Threads vs Multiple Objects (in Simple Terms):
-------------------------------------------------------------

When you create multiple objects of a class and call their methods, everything still runs on the same main thread — one after another.
That’s sequential execution: your CPU finishes one task completely before starting the next.

To make tasks run at the same time, we use threads.
A thread is an independent path of execution — it lets the CPU handle multiple jobs concurrently.
If your CPU has 8 cores, it can truly run 8 threads in parallel; any extra threads just wait their turn.

However, threads aren’t free. Each one needs memory and CPU time for context switching.
If you create too many threads (like millions), your system will choke — you’ll run out of memory, and performance will tank.

That’s why in real projects, we don’t spawn a new thread for every small task.
We use thread pools (like ExecutorService) or asynchronous programming models that reuse a fixed number of threads efficiently.

⚙️ In short:

Objects define what to do.
Threads define when and how many things run at once.
CPU cores limit true parallelism — 8 cores → 8 simultaneous threads.
Too many threads = waste + crash.
Thread pools = controlled, efficient concurrency.

=====================
User Defined Threads
=====================

-> In Java we can create Thread in 2 ways

1) By extending Thread class
2) By Implementing Runnable interface

// Java program to create user defined thread using Thread class

public class Demo extends Thread {

	public void run() {
		System.out.println("run () method called...");
	}

	public static void main(String... args) {

		Thread d = new Demo();
		d.start();
	}
}


// Java program to create the thread using Runnable interface

public class Demo implements Runnable {

	public void run() {
		System.out.println("run () method called...");
	}

	public static void main(String... args) {

		Demo d = new Demo();

		Thread t = new Thread(d);
		t.start();
	}
}


=====================================================================================================================
Q) What is the difference between extending Thread class and implementing Runnable interface, which is recommended ?
=====================================================================================================================

-> If we extend properties from Thread class then we can't extend properties from any other class because java doesn't support multiple inheritance. (We are closing gate for Inheritance)

-> If we implement Runnable interface then in future we can extend properties from any class based on requirement. (Our gate is open for inheritance)

Note: Implementing Runnable interface is always recommended.

=======================
What is Thread Schedular
=======================

-> Thread Schedular is a program in the JVM which is responsible to schedule Threads execution and resources allocation required for the thread.
-> When we call start ( ) method then Thread Schedular will start its operation.

			1) Allocating Resources
			2) Thread Scheduling
			3) Thread Execution by calling run ( ) method

JVM vs Thread Scheduler
=======================

| Feature             | JVM                                      | Thread Scheduler (OS)                         |
| ------------------- | ---------------------------------------- | --------------------------------------------- |
| Location            | Java runtime                             | Operating System                              |
| Responsibility      | Thread lifecycle, memory, Java-level API | CPU allocation, preemption, context switching |
| Controls execution? | No, only manages states                  | Yes, decides actual execution order           |
| Guarantees order?   | No                                       | No (depends on algorithm & CPU)               |

========
Analogy:  Hardware core vs Hardware thread vs Program thread
========

Your 4 workers (cores) with 2 hands (hardware threads each) — total 8 hands.
If your program spawns 20 software threads (jobs), only 8 can work at once, others wait their turn.
The OS keeps switching between them very fast (called context switching).
					      ===========================
=====================================
start  ( ) method  vs run ( ) method
=====================================

-> To start thread execution we will call start ( ) method
			t.start ( )

-> once start ( ) method is called then Thread Schedular will come into picture to execute our thread
-> start ( ) method will call run ( ) method internally
-> inside run ( ) method we will write the logic which should be executed by the thread.


=====================================================================
Can we call run ( ) method directly without calling start ( ) method
=====================================================================

-> Yes, we can call run ( ) method directly but it will execute like a normal method (there is no use) by "main" thread.
-> If we want to execute run ( ) method as a thread  method then we should call start ( ) method then internally it will call run ( ) method (Thread Schedular will take care of thread execution)


public class Demo implements Runnable {

	public void run() {
		System.out.println("run () method started...");

		Thread t = Thread.currentThread();
		System.out.println(t.getName());

		System.out.println("run () method ended...");
	}

	public static void main(String... args) {
		Demo d = new Demo();

		Thread t = new Thread(d);
		//t.start();
		//t.run();
	}
}


=> If we call start () method then run () method will be executed by our user defined thread (we can see thread name as Thread-0)
=> if we call run () method then run () method will be executed by "main" thread (we can see thread name as main)


NOTE: "Main method is the run method of the main thread”:
========================================================

When a Java program starts, JVM automatically creates a thread called “main thread.”
The main thread is responsible for executing the code inside the main() method.
So, the JVM internally treats your main() method as the entry point (run method) of that main thread.
You don’t write run() manually — JVM calls main() on behalf of the main thread.

Therefore:
main() acts like the run() method of the main thread.

=========================
What is Thread Life Cycle
=========================

-> Thread Life cycle contains several phases of Thread execution

1) New
2) Runnable
3) Running
4) Blocked
5) Terminated


New        : A thread begins its life cycle in the new state.Thread remains in the new state until we will call start( ) method.
Runnable   : After calling start () method, thread comes from new state to runnable state.
Running    : A thread comes to running state when Thread Schedular will pick up that thread for execution.
Blocked    : A thread is in waiting state if it waits for another thread to complete its task.
Terminated : A thread enters into terminated state once it completes its task.

=====================================================================================
Thread Life Cycle & JVM Responsibilities (os also has its role in thread lifecycle)
=====================================================================================

| State                 | What happens                                                                     | Who manages it                                                                                               |
| --------------------- | -------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| **New**               | Thread object is created but `start()` is **not called yet**.                    | JVM (creates the Thread object)                                                                              |
| **Runnable**          | `start()` is called, thread is ready to run but **waiting for CPU**.             | JVM moves it to Runnable state; OS scheduler decides actual CPU execution.                                   |
| **Running**           | Thread is actually executing its `run()` method.                                 | **OS scheduler** picks the thread from Runnable queue and runs it on CPU. JVM doesn’t control this directly. |
| **Blocked / Waiting** | Thread is waiting for another thread (e.g., I/O, `sleep()`, `wait()`, `join()`). | JVM marks the thread as blocked/waiting; OS ensures it doesn’t run until ready.                              |
| **Terminated**        | Thread has completed execution.                                                  | JVM updates its state to Terminated. The thread cannot be restarted.                                         



// Java Program on Thread Sleep

public class Demo implements Runnable {

	public void run() {
		System.out.println("run () method started...");

		try {
			Thread.sleep(5000); // blocked state
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println("run () method ended...");
	}

	public static void main(String... args) {
		Demo d = new Demo();
		Thread t = new Thread(d); // new state
		t.start(); // runnable state
	}
}

Analogy Thread.sleep();  E:\JRTP\Multithreading\Demo.java
======================

Think of the CPU as a single cashier and threads as customers:
A customer (Thread) is being served → Running
Customer takes a 5-second break (sleep(5000)) → cashier serves someone else
After 5 seconds → customer rejoins the line → waits for turn again

✅ Bottom line:
Thread.sleep() pauses the thread, removes it temporarily from CPU execution, 
and allows other threads to run on that CPU core. It does not block the CPU.

=> Thread.sleep() always pauses the currently executing thread — the one that’s running that line of code.

// Java program to start multiple threads to perform same activity

public class Demo implements Runnable {

	public void run() {
		System.out.println("run () method started..." + Thread.currentThread().getName());
		try {
			Thread.sleep(15000); // blocked state
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println("run () method ended..." + Thread.currentThread().getName());
	}

	public static void main(String... args) {
		Demo d = new Demo();

		Thread t1 = new Thread(d);
		t1.setPriority(Thread.MAX_PRIORITY); // 10
		t1.setName("Thread-1");

		Thread t2 = new Thread(d);
		t2.setPriority(Thread.NORM_PRIORITY); // 5
		t2.setName("Thread-2");

		Thread t3 = new Thread(d);
		t3.setPriority(Thread.MIN_PRIORITY); // 1
		t3.setName("Thread-3");

		t1.start(); // runnable state
		t2.start(); // runnable state
		t3.start(); // runnable state
	}
}

Note: We shouldn't start one thread more than one time.

public static void main(String... args) {
		Demo d = new Demo();

		Thread t1 = new Thread(d);

		t1.start();
		t1.start(); // java.lang.IllegalThreadStateException
	}

Note:
Whenever you use Thread.sleep() (or wait(), join(), BlockingQueue.take() etc.),
you must handle or declare InterruptedException, because it’s how threads cooperate to pause and resume safely.

Thread Priority:
================

Thread priority is just a hint to the JVM and OS about which thread should get more CPU time, but it does not guarantee any execution order. Modern operating systems mostly ignore these priorities, so threads with high and low priority usually behave the same. Priority may only show impact in rare CPU-intensive scenarios, not in normal applications.


=========================
threadObject.interrupt() : E:\JRTP\Multithreading\RunningThreadInterruptSimple.java
=========================

Analogy:
========

Imagine a person taking a nap for 10 minutes (sleep).

If no one wakes them → they wake naturally after 10 minutes.

If someone shakes them (interrupt) → they wake immediately.

What they do next is their choice: get up and work, go back to sleep, or leave.
---------------------------------------------------------------------------------------

interrupt() does not force stop, it signals a thread.

Thread in sleep/wait/join:

Interrupted → throws InterruptedException → can handle or stop

Not interrupted → sleeps full duration

Thread in "running" state: Interrupted → must check flag manually → decide what to do -> if thread running then it set flag to true 

The real use: graceful cancellation and cooperative stopping of threads


public class SleepInterruptDemo implements Runnable {

    @Override
    public void run() {
        try {
            System.out.println("Worker thread started, going to sleep...");
            
            // Thread goes to sleep for 10 seconds
            Thread.sleep(10000);
            
            System.out.println("Worker thread woke up normally after 10 sec.");
        } 
        catch (InterruptedException e) {
            System.out.println("Worker thread got interrupted while sleeping!");
        }

	// More logic continues here
	System.out.println("Worker thread doing cleanup...");
	System.out.println("Worker thread finishing its job...");
    }

    public static void main(String[] args) {
        SleepInterruptDemo demo = new SleepInterruptDemo();
        Thread worker = new Thread(demo);

        worker.start();  // Start the worker thread

        try {
            // Main thread sleeps for 3 seconds
            Thread.sleep(3000);
        } 
        catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Main thread interrupting worker thread...");
        worker.interrupt();  // Interrupt the worker while it’s still sleeping
    }
}

=================
Callable Interface
=================

-> This interface introduced in java 1.5
-> Using Callable interface also we can create the Thread
-> This interface contains call ( ) method.

Syntax:
			public Object call ( ) 

==============================================================
What is the difference between Runnable & Callable interfaces  E:\JRTP\Multithreading\RunnableCallableMixClassic.java
==============================================================

-> Runnable is a functional interface which contains run ( ) method
-> Callable is a functional interface which contains call ( ) method

-> Runnable run ( ) method returns void (no return type)
-> Callable call ( ) method returns Object

-> Runnable interface present in java.lang package
-> Callable interface present in java.util.concurent package


=============================================================
ExecutorService   E:\JRTP\Multithreading\ThreadPoolTrace.java
==============================================================

-> Executor Service introduced in java 1.5v
-> Using ExecutorService we can implement multi threading
-> Using Executors we can create thread pool
-> Using Executor Service we can submit tasks to pool of threads.
-> ExecutorService will re-use threads available in the pool to complete all submitted tasks.

// Java Program on Executor Service with Callable interface

package in.ashokit;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Demo implements Callable {

	public Object call() throws Exception {
		System.out.println("call ( ) - method executed...");
		return "success";
	}

	public static void main(String[] args) throws Exception {
		Demo d = new Demo();
		
		ExecutorService exService = Executors.newFixedThreadPool(10);

		for (int i = 1; i <= 15; i++) {
			Future submit = exService.submit(d);
			System.out.println(submit.get().toString());
		}
		exService.shutdown();
	}
}

| Feature            | Normal Threads                                  | ExecutorService                                |
| ------------------ | ----------------------------------------------- | ---------------------------------------------- |
| Thread creation    | Every task creates a new thread                 | Threads created once and **reused**            |
| Thread destruction | Dies after run() ends                           | Kept alive and reused                          |
| Number of threads  | Unlimited (depends on how many you create)      | Fixed or controlled                            |
| Return value       | Not supported (`Runnable.run()` returns `void`) | Supported (`Callable.call()` + `Future.get()`) |
| Performance        | Expensive when tasks are frequent               | Efficient and scalable                         |

=============
Daemon Thread
=============

We have 3 types of threads in java

1) Default thread created by JVM ( main thread )
2) User Defined Threads ( Thread class, Runnable interface, Callable interface )
3) Daemon Threads

Note: The thread which runs in the background is called as Dameon Thread. Daemon Threads also called as low priority threads.

Ex: Garbage Collector is a daemon thread
-> We can make our thread as Daemon Thread using setDaemon() method

// Java Program To Make thread as Daemon

package in.ashokit;
public class Demo implements Runnable {

	@Override
	public void run() {

		if (Thread.currentThread().isDaemon()) {
			System.out.println("Daemon Thread Executed...");
		} else {
			System.out.println("Normal Thread Executed...");
		}
	}

	public static void main(String[] args) {
		Demo d = new Demo();
		Thread t1 = new Thread(d);
		t1.setDaemon(true);
		t1.start();
	}
}

-> When JVM reaches end of main method, it will terminate our program. If JVM founds Daemon thread running it terminates that daemon thread and then it will shutdown the program.

-> JVM will not care about Daemon Threads running status to stop the program execution.

===============
Synchronization
===============

| **Rule**                   | **When to Apply `synchronized`**                                         | **When NOT to Use `synchronized`**                                         |
| -------------------------- | ------------------------------------------------------------------------ | -------------------------------------------------------------------------- |
| **1. Shared Mutable Data** | When multiple threads modify/read the **same shared variable/object**.   | When data is **local to method** or each thread has its own copy.          |
| **2. Critical Section**    | Protect only the **small part** of code that updates shared state.       | Do NOT wrap the entire method if only a small portion needs protection.    |
| **3. Stable Lock Object**  | Lock on **`this`**, a **final lock object**, or **class object**.        | Never lock on `new Object()` or objects that keep changing.                |
| **4. Instance vs Static**  | Use `synchronized` method/block for instance data shared across threads. | Don’t use instance lock for static data. Use class-level lock instead.     |
| **5. Slow Operations**     | Use only around actual shared-variable update.                           | Avoid locking slow code (sleep, I/O, logs, DB calls) → leads to blocking.  |
| **6. Full Consistency**    | Ensure **every** access to the shared resource is synchronized.          | Never mix synchronized + unsynchronized access → leads to race conditions. |
| **7. Thread-Safety Needs** | When you need strict mutual exclusion.                                   | When using thread-safe classes like `ConcurrentHashMap`, `AtomicInteger`.  |


String ----> Immutable class
StringBuffer ----> Mutable class & synchronized class (Thread safe class)
StringBuilder ---> Mutable class & not-synchronized class  (Not Thread Safe class)

Synchronized means Thread safe ===> Only one thread can access the object / resource at a time
Not-Synchronized means Not Thread Safe   => Multiple threads can access same resource / object at a time

public class MovieTicketBooking  {

		int avilableTickets = 100;
		public void run ( ) {
			if ( availableTickets > 0 ) {		
				// logic to bookTicket;	
				-- avilableTickets ;
			}
		}

		psvm ( ) {
				Thread t1 = new Thread();
				Thread t2 = new Thread();
				Threa  t20 = new Thread();

				t1..... t20 ---start
		}
}

-> In the program, multiple threads are trying to book tickets at a time

Note: If multiple threads access the same object at a time then there is a chance of getting data inconsistency problem.


=> To avoid data inconsistency problem, we need to use Synchronization concept
=> Synchronization means allowing only one thread to execute our resource / object / logic at a time

Note: By Using Synchronization we can achieve Thread Safety but it will slow down our execution process.

===========================
How to achieve synchronization
===========================

-> Using  'synchronized' keyword we can implement synchronization
-> synchronized keyword we can use at two places

1)  At method level
2)  At block level

--------------------------------------------
Syntax For Synchronized Block:
--------------------------------------------

public void m1( ){

	// pre-logic

	synchronized ( object ) {
		// imp business logic
	}	
	
	// post-logic

}

EX:
private int balance = 1000;
private final Object lock = new Object();

public void deposit(int amount) {

    // pre logic...

    synchronized(lock) {
        // Critical section using shared variable
        balance += amount;
    }

    // post logic...
}

-----------------------------------
Syntax For Synchronized Method :
-----------------------------------

public synchronized void m1( ) {

	// important business logic

}

// Java Program with Synchronized Method

public class Demo implements Runnable {

	public synchronized void printNums() {
		for (int i = 1; i <= 10; i++) {
			System.out.println(Thread.currentThread().getName() + "=> " + i);
			try {
				Thread.sleep(1000);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}

	public void run() {
		printNums();
	}

	public static void main(String[] args) {
		Demo d = new Demo();

		Thread t1 = new Thread(d);
		t1.setName("Thread-1");
		t1.start();

		Thread t2 = new Thread(d);
		t2.setName("Thread-2");
		t2.start();
	}
}

Note: In the above program we are starting 2 threads. two threads will access printNums ( ) method to print the numbers from 1 to 10.

-> If printNums ( ) method having synchronized keyword then two threads will execute the method sequentially one after other .
-> if we remove synchronized keyword from the printNums ( ) method then two threads will access that method at a time.

Note: We can see the difference in the output.


===================================================
Working with Threads using Anonymous Implementation
===================================================

import java.util.concurrent.*;

class ThreadDemo {

    public static void main(String[] args) {

        Thread t1 = new Thread() {
            public void run() {
                System.out.println("run() method logic-1");
            }
        };
        t1.start();

        Runnable r = new Runnable() {
            @Override
            public void run() {
                System.out.println("run() method logic-2");
            }
        };
        Thread t2 = new Thread(r);
        t2.start();

        Callable<Object> c = new Callable<Object>() {
            public Object call() throws Exception {
                System.out.println("call() method logic-3");
                return null;
            }
        };

        ExecutorService exService = Executors.newFixedThreadPool(1);
        exService.submit(c);
        exService.shutdown();
    }
}


==========
Dead Lock
=========

-> Dead Lock means ambiguity problem among the threads
-> If 2 threads are waiting for each other to release the resources is called as dead lock.
-> Once we get into dead lock situation then we can't do anything

Ex:
----

Thread-1  holding resource-1  and waiting for resource-2
Thread-2  holding resource-2 and waiting for resource-1

Note: 

Thread-1 will not release resource-1 hence thread-2 will be in waiting state forever for resource-1
Thread-2 will not release resource-2 hence thread-1 will be in waiting state forever for resource-2

// Java program which will give dead lock

public class DeadLock {

    public static void main(String[] args) {

        final String resource1 = "Resource-1";
        final String resource2 = "Resource-2";

        // Thread 1 tries to lock resource1 first, then resource2
        Thread t1 = new Thread(() -> {
            synchronized (resource1) {
                System.out.println("Thread-1 locked " + resource1);

                try {
                    Thread.sleep(100); // let Thread-2 lock resource2
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                System.out.println("Thread-1 waiting to lock " + resource2);
                synchronized (resource2) {
                    System.out.println("Thread-1 locked " + resource2);
                }
            }
        });

        // Thread 2 tries to lock resource2 first, then resource1
        Thread t2 = new Thread(() -> {
            synchronized (resource2) {
                System.out.println("Thread-2 locked " + resource2);

                	try {
                    		Thread.sleep(100); // let Thread-1 lock resource1
                	} catch (InterruptedException e) {
                    		e.printStackTrace();
                	}

                System.out.println("Thread-2 waiting to lock " + resource1);
                synchronized (resource1) {
                    System.out.println("Thread-2 locked " + resource1);
                }
            }
        });

        t1.start();
        t2.start();
    }
}

===============
join ( ) method
===============

-> join ( ) method is used to hold second thread execution until first thread execution got completed

public class Demo {

	public static void main(String[] args) throws Exception {

		Thread t1 = new Thread() {
			public void run() {
				for (int i = 1; i <= 5; i++) {
					System.out.println(Thread.currentThread().getName() + " => " + i);
					try {
						Thread.sleep(100);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			}
		};
		t1.setName("Thread-1");

		Thread t2 = new Thread() {
			public void run() {
				for (int i = 1; i <= 5; i++) {
					System.out.println(Thread.currentThread().getName() + " => " + i);
					try {
						Thread.sleep(100);
						Thread.yield();
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			}
		};
		t2.setName("Thread-2");

		t1.start();
		t1.join();
		t2.start();
	}
}


Output:
Thread-1 => 1
Thread-1 => 2
Thread-1 => 3
Thread-1 => 4
Thread-1 => 5
Thread-2 => 1
Thread-2 => 2
Thread-2 => 3
Thread-2 => 4
Thread-2 => 5

================
yield ( ) method
================

-> yield ( ) method is used to give chance for other equal priority threads to execute

Key Point About yield():
=========================

yield() does NOT guarantee the other thread will run next.
It only suggests to the JVM scheduler:
“Hey, if another thread of equal priority is waiting, let it run.”
Most modern JVMs ignore yield() or treat it very lightly.
So output is non-deterministic — threads can interleave in ANY order.

// Java program with yield ( ) method

package in.ashokit;

public class YieldDemo {

	public static void main(String[] args) {
		Thread producer = new Producer();
		Thread consumer = new Consumer();

		producer.start();
		consumer.start();
	}
}

class Producer extends Thread {
	public void run() {
		for (int i = 0; i < 3; i++) {
			System.out.println("Producer : Produced Item " + i);
			Thread.yield();
		}
	}
}

class Consumer extends Thread {
	public void run() {
		for (int i = 0; i < 3; i++) {
			System.out.println("Consumer : Consumed Item " + i);
			Thread.yield();
		}
	}
}



==========================
Inter Thread Communication
==========================

-> It is used to establish communication among the threads
-> To achieve inter thread communication we have below 3 methods in "Object class"

		1) wait ( )
		2) notify ( )
		3) notifyAll ( )

Q) Why these 3 methods available in Object class, why not in Thread class ?

-> If these methods available in Thread class then we have to extend Thread class. In future we can't extend from any other java class bcz java is against for Multiple Inheritance.
-> If these methods available in Runnable interface then everybody should implement these method even if they don't need inter thread communication.
-> To overcome all these problems, java kept these methods in Object class so that every class will have access for these methods.



What notify() actually does

A thread must first call wait() on an object.
That thread goes into the waiting state for that object’s monitor.
When another thread calls notify() on the same object, one waiting thread is woken up.
The awakened thread will continue exactly after the wait() call, not some random method.

// Java Program to establish inter thread communication

package in.ashokit;

public class Customer {

	int amount = 10000;

	synchronized void withdraw(int amount) {
		System.out.println("going to withdraw...");
		if (this.amount < amount) {
			System.out.println("Less balance; waiting for deposit...");
			try {
				wait();
			} catch (Exception e) {
			
			}
		}
		this.amount -= amount;
		System.out.println("withdraw completed...");
	}

	synchronized void deposit(int amount) {
		System.out.println("going to deposit...");
		this.amount += amount;
		System.out.println("deposit completed... ");
		notify();
	}

	public static void main(String args[]) {
		final Customer c = new Customer();

		new Thread() {
			public void run() {
				c.withdraw(15000);
			}
		}.start();

		try {
			Thread.sleep(20000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

		new Thread() {
			public void run() {
				c.deposit(10000);
			}
		}.start();
	}
}







================================
Multi Threading Summary
=================================
1) What is Multi Tasking
2) What is Multi Threading
3) Advantages of Multi Threading
4) Default Thread in JVM (main)
5) Getting info of main thread ( Thread.currentThread( ) )
6) Creating User Defined Threads
7) By Extending Thread class
8) By Implementing Runnable interface
9) By implementing Callable interface
10) run ( ) method vs call ( )
11) Executor Service
12) run ( ) vs start ( ) method
13) Thread Life Cycle
14) Thread Schedular
15) Synchronization (method & block)
16) What is Thread Safety
17) Thread creation with Anonymous implementation
18) Dead Lock (Java Program to give dead lock)
19) join ( ) method vs yield ( ) method
20) Inter Thread Communication
21) Daemon Threads















